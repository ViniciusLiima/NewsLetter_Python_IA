# -*- coding: utf-8 -*-
"""Projeto_Python_NewsLetter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GABr1c0TMsPJqkje93h9VhHkEyDX31e6

# Projeto de Newsletter DiÃ¡ria de CotaÃ§Ã£o de Moedas ğŸ“¨ğŸ“ˆ

## CONFIGURAÃ‡ÃƒO DE AMBIENTE âš™ï¸
"""

# Bibliotecas necessÃ¡rias
import os
import yaml
import json
import logging
import requests
import smtplib
import pandas as pd
import google.generativeai as genai
import matplotlib.pyplot as plt
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders

# Lista com os nomes dos diretÃ³rios a serem criados
directories = ["01_bronze", "02_silver", "03_gold", "04_graphs", "05_ia_responses"]

# Criar diretÃ³rios
for directory in directories:
    try:
        # Tenta criar o diretÃ³rio. Se ele jÃ¡ existir, o erro FileExistsError Ã© gerado.
        os.mkdir(directory)
        print(f"DiretÃ³rio '{directory}' criado com sucesso.")
    except FileExistsError:
        # Se o diretÃ³rio jÃ¡ existir, uma mensagem Ã© impressa.
        print(f"O diretÃ³rio '{directory}' jÃ¡ existe.")
    except Exception as e:
        # Para qualquer outro tipo de erro, uma mensagem genÃ©rica Ã© exibida.
        print(f"Ocorreu um erro ao criar o diretÃ³rio '{directory}': {e}")

"""##CONFIGURAÃ‡ÃƒO DE LOG

"""

# Cria um objeto logger com o nome 'newsletter_logger'
newsletter_logger = logging.getLogger('newsletter_logger')

# Define o nÃ­vel de registro como DEBUG. Isso significa que todas as mensagens com nÃ­vel DEBUG e acima serÃ£o registradas
newsletter_logger.setLevel(logging.DEBUG)

# Criae manipuladores que imprimem mensagens de log no console (saÃ­da padrÃ£o) e escrevem mensagens de log em um arquivo chamado 'newsletter_logger.log'
console_handler = logging.StreamHandler()
file_handler = logging.FileHandler('newsletter_logger.log')

# Define um formatador que especifica o formato das mensagens de log
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Define o formatador para o manipulador do console e para o manipulador de arquivos
console_handler.setFormatter(formatter)
file_handler.setFormatter(formatter)

# Adiciona o manipulador do console ao logger. Isso significa que mensagens de log serÃ£o exibidas no console
#newsletter_logger.addHandler(console_handler)

# Adiciona o manipulador de arquivos ao logger. Isso significa que mensagens de log serÃ£o escritas no arquivo 'newsletter_logger.log'
newsletter_logger.addHandler(file_handler)

# Gera Log
newsletter_logger.info("ConfiguraÃ§Ãµes de Log")

"""## CONFIGURAÃ‡Ã•ES DE FUNÃ‡Ã•ES"""

# Gera Log
newsletter_logger.info("ConfiguraÃ§Ãµes de FunÃ§Ãµes")

def obter_taxas_de_cambio(api_key):
    """
    FunÃ§Ã£o para obter as taxas de cÃ¢mbio da API ExchangeRate-API.com.

    Args:
        api_key (str): Sua chave de API da ExchangeRate-API.com.

    Returns:
        dict: Um dicionÃ¡rio com as taxas de cÃ¢mbio ou None em caso de erro.
    """
    url = f"https://v6.exchangerate-api.com/v6/{api_key}/latest/BRL"

    try:
        response = requests.get(url)
        response.raise_for_status()  # LanÃ§a uma exceÃ§Ã£o para respostas com erro (status code 4xx ou 5xx)

        dados = response.json()

        if dados.get("result") == "success":
            return dados.get("conversion_rates")
        else:
            newsletter_logger.info(f"Erro na resposta da API: {dados.get('error-type')}")
            return None

    except requests.exceptions.RequestException as e:
        newsletter_logger.info(f"Erro ao fazer a requisiÃ§Ã£o: {e}")
        return None

def enviar_email_com_anexo(remetente, senha, destinatario, assunto, corpo, caminho_anexo):
    """
    Envia um e-mail com um anexo.

    Args:
        remetente (str): EndereÃ§o de e-mail do remetente.
        senha (str): Senha do aplicativo/gerada do e-mail do remetente.
        destinatario (str): EndereÃ§o de e-mail do destinatÃ¡rio.
        assunto (str): Assunto do e-mail.
        corpo (str): Corpo do texto do e-mail.
        caminho_anexo (str): Caminho completo para o arquivo a ser anexado.
    """
    # ConfiguraÃ§Ãµes do e-mail
    msg = MIMEMultipart()
    msg['From'] = remetente
    msg['To'] = destinatario
    msg['Subject'] = assunto

    # Anexa o corpo do e-mail
    msg.attach(MIMEText(corpo, 'plain'))

    # Anexa o arquivo
    try:
        with open(caminho_anexo, "rb") as anexo:
            parte = MIMEBase("application", "octet-stream")
            parte.set_payload(anexo.read())

        encoders.encode_base64(parte)

        # Define o nome do arquivo no cabeÃ§alho
        nome_arquivo = os.path.basename(caminho_anexo)
        parte.add_header("Content-Disposition", f"attachment; filename={nome_arquivo}")

        msg.attach(parte)

    except FileNotFoundError:
        newsletter_logger.info(f"Erro: O arquivo {caminho_anexo} nÃ£o foi encontrado.")
        return
    except Exception as e:
        newsletter_logger.info(f"Ocorreu um erro ao anexar o arquivo: {e}")
        return

    # Conecta ao servidor e envia o e-mail
    try:
        servidor_smtp = "smtp.gmail.com"  # Exemplo para Gmail
        porta_smtp = 587

        with smtplib.SMTP(servidor_smtp, porta_smtp) as servidor:
            servidor.starttls()  # Inicia a seguranÃ§a TLS
            servidor.login(remetente, senha)
            servidor.send_message(msg)
            newsletter_logger.info("E-mail enviado com sucesso!")

    except smtplib.SMTPAuthenticationError:
        newsletter_logger.info("Erro de autenticaÃ§Ã£o. Verifique seu e-mail e senha do aplicativo.")
    except Exception as e:
        newsletter_logger.info(f"Ocorreu um erro ao enviar o e-mail: {e}")

"""## DEFINE VARIAVEIS"""

# Gera Log
newsletter_logger.info("DefiniÃ§Ã£o de variaveis")

# Define Data atual
data_atual = datetime.now()

# Define Data atual no formato '%Y-%m-%d'
data_atual_str = data_atual.strftime('%Y-%m-%d')

# Define diretÃ³rio e arquivo - Camada BRONZE
bronze_dir = os.path.join("01_bronze/", f"exchange_rates_bronze_{data_atual_str}.json")

# Define diretÃ³rio e arquivo - Camada SILVER
silver_dir = os.path.join("02_silver/", f"exchange_rates_normalized_{data_atual_str}.json")

# Define diretÃ³rio e arquivo - Camada GOLD
gold_dir = os.path.join("03_gold/", f"exchange_rates_{data_atual_str}.parquet")

# Define diretÃ³rio e arquivo - GrÃ¡ficos
graph_dir = os.path.join("04_graphs/", f"grafico_taxas_de_cambio_{data_atual_str}.pdf")

# Define diretÃ³rio e arquivo - SaÃ­da IA
ia_output_dir = os.path.join("05_ia_responses/", f"ia_output.json")

# O nome do arquivo YAML
yaml_file = "config.yaml"

# Variaveis arquivo YAML
try:
  with open(yaml_file, "r") as arquivo_yaml:
    # Carrega o conteÃºdo do arquivo YAML em um dicionÃ¡rio Python
    configuracoes = yaml.safe_load(arquivo_yaml)

  # ExchangeRate API Key
  exchangerate_key = configuracoes['api_keys']['exchangerate_api_key']

  # Gemini API Key
  gemini_key = configuracoes['api_keys']['gemini_api_key']

  # Gemini API model
  gemini_model = configuracoes['ia_model']['gemini_model']

  # Define email e senha para envio do relatÃ³rio
  meu_email = configuracoes['email']['meu_email']
  minha_senha_app = configuracoes['email']['minha_senha_app']

  # Define email do assinante
  email_destinatario = configuracoes['email']['email_destinatario']

except FileNotFoundError:
  newsletter_logger.info(f"Erro: O arquivo '{yaml_file}' nÃ£o foi encontrado. Verifique o caminho e o nome do arquivo.")
except KeyError as e:
  newsletter_logger.info(f"Erro: Chave nÃ£o encontrada no arquivo YAML. Verifique a estrutura. Chave faltando: {e}")
except Exception as e:
  newsletter_logger.info(f"Ocorreu um erro ao carregar o arquivo YAML: {e}")

"""## 1Â° PASSO: COLETA DE DADOS DA API E ARMAZENAMENTO BRUTO (CAMADA BRONZE) ğŸ¥‰"""

# Gera Log
newsletter_logger.info("1Â° PASSO: COLETA DE DADOS DA API E ARMAZENAMENTO BRUTO (CAMADA BRONZE)")

# Executa funÃ§Ã£o para retornar taxas
taxas = obter_taxas_de_cambio(exchangerate_key)

# json.dump escreve o dicionÃ¡rio Python em um arquivo no formato JSON
# indent=4 formata o JSON para ser mais legÃ­vel
# ensure_ascii=False garante que caracteres especiais (como R$) sejam salvos corretamente
with open(bronze_dir, 'w', encoding='utf-8') as json_file:
    json.dump(taxas, json_file, indent=4, ensure_ascii=False)

# Gera Log
newsletter_logger.info(f"Taxas de cÃ¢mbio salvas com sucesso em: {bronze_dir}")

"""## 2Â° PASSO: CAPTURAR DADOS DA CAMADA BRONZEğŸ¥‰, NORMALIZAR E GRAVAR NA CAMADA SILVERğŸ¥ˆ"""

# Gera Log
newsletter_logger.info("2Â° PASSO: CAPTURAR DADOS DA CAMADA BRONZE, NORMALIZAR E GRAVAR NA CAMADA SILVER")

# Le o arquivo JSON
with open(bronze_dir, 'r', encoding='utf-8') as json_file:
    taxas_dict = json.load(json_file)

# Converte o dictionary para uma lista de tuplas e entÃ£o para DataFrame
df_silver = pd.DataFrame(list(taxas_dict.items()), columns=['Moeda', 'Taxa'])

# Garante a qualidade dos dados (remover taxas nulas ou negativas)
df_silver_qa = df_silver[df_silver['Taxa'] > 0].copy()

# Normalizr os dados adicionando as novas colunas
moeda_base = 'BRL' # Define moeda base como BRL
df_silver_qa['Moeda_Base'] = moeda_base
df_silver_qa['Timestamp'] = pd.Timestamp.now()

# Reordenr colunas para melhor organizaÃ§Ã£o
df_silver_qa = df_silver_qa[['Moeda', 'Taxa', 'Moeda_Base', 'Timestamp']]

# Salva em formato JSON
df_silver_qa.to_json(silver_dir)

# Gera Log
newsletter_logger.info(f"DataFrame da camada Bronze processado com sucesso e salvo na camada Silver em: {silver_dir}")

"""##3Â° PASSO: CAPTURAR DADOS DA CAMADA SILVERğŸ¥ˆ E GRAVAR EM PARQUET NA CAMADA GOLDğŸ¥‡"""

# Gera Log
newsletter_logger.info("3Â° PASSO: CAPTURAR DADOS DA CAMADA SILVER E GRAVAR EM PARQUET NA CAMADA GOLD")

# Le o arquivo JSON
with open(silver_dir, 'r', encoding='utf-8') as json_file:
    taxas_dict = json.load(json_file)
df_gold = pd.read_json(silver_dir)

# Filtra apenas USD e JPY
df_gold = df_gold[df_gold['Moeda'].isin(['USD', 'JPY'])]

# Salva em formato Parquet sem o Ã­ndice do DataFrame
df_gold.to_parquet(gold_dir, index=False)

newsletter_logger.info(f"DataFrame da camada Silver processado com sucesso e salvo na camada Gold em: {gold_dir}")

df_gold

"""## 4Â° PASSO: GERA GRÃFICO COM AS PRINCIPAIS MOEDAS ğŸ“ˆğŸª™ğŸ’±"""

# Gera Log
newsletter_logger.info("4Â° PASSO: GERA GRÃFICO COM AS PRINCIPAIS MOEDAS" )

# Le o arquivo PARQUET
df_graph = pd.read_parquet(gold_dir)

# --- InÃ­cio das configuraÃ§Ãµes de grÃ¡fico ---
plt.figure(figsize=(8, 6)) # Opcional: ajusta o tamanho da figura para melhor visualizaÃ§Ã£o
plt.bar(df_graph['Moeda'], df_graph['Taxa'], color='cornflowerblue')

# AdiÃ§Ã£o para incluir os valores nas barras
# Loop para percorrer cada barra do grÃ¡fico
for index, value in enumerate(df_graph['Taxa']):
    # plt.text(x, y, texto, alinhamento_horizontal)
    # x = index (posiÃ§Ã£o da barra: 0, 1, 2...)
    # y = value + offset (altura da barra + um pequeno espaÃ§o para nÃ£o ficar colado)
    # texto = f'{value:.2f}' (o valor formatado com 2 casas decimais)
    plt.text(index, value + 0.05, f'R$ {value:.2f}', ha='center', fontsize=10)
# --- Fim das configuraÃ§Ãµes de grÃ¡fico ---

# Adiciona tÃ­tulos e rÃ³tulos
plt.xlabel('Moeda', fontsize=12)
plt.ylabel('Taxa de CÃ¢mbio (R$)', fontsize=12)
plt.title(f'Taxas de CÃ¢mbio - {data_atual.strftime("%d/%m/%Y")}', fontsize=14)
plt.xticks(rotation=45, ha='right') # Rotaciona os rÃ³tulos do eixo x para evitar sobreposiÃ§Ã£o
plt.grid(axis='y', linestyle='--', alpha=0.7) # Adiciona uma grade horizontal
plt.tight_layout() # Ajusta o layout para garantir que tudo se encaixe bem

# Salva o grÃ¡fico no arquivo PDF
plt.savefig(graph_dir, format='pdf')

newsletter_logger.info(f"GrÃ¡fico salvo com sucesso no arquivo: '{graph_dir}'")

"""## 5Â° PASSO: GERAR CONTEÃšDO DO EMAIL COM IA-GEMINIğŸ¤– E GRAVAR EM JSON ğŸ—ƒï¸"""

# Gera Log
newsletter_logger.info("5Â° PASSO: GERAR CONTEÃšDO DO EMAIL COM IA (GEMINI)")

# Utiliza credenciais do Gemini
genai.configure(api_key=gemini_key)

# Inicializa modelo do Gemini
model = genai.GenerativeModel(f'{gemini_model}')

# Define o prompt
prompt = f"""
VocÃª Ã© um agente especialista no mercado financeiro, responsÃ¡vel por ler dados sobre o valor do USD e JPY frente ao BRL.
Use os dados fornecidos sobre a cotaÃ§Ã£o da moeda e gere um texto de Newsletter informando noticias relevantes no dia de hoje, que tenhan relaÃ§Ã£o com USD e JPY.

Acrecente ao final links de notÃ­cias relevantes do dia, sobre o tema. Os links devem estar funcionado para que o assinante acesse.
Acrescente ao final a frase: 'Atenciosamente, Seu Consultor Financeiro.'.

### Exemplo de Saida esperada: 'OlÃ¡, Assinante. Hoje a cotaÃ§Ã£o do USD ficou em 0,18 e do JPY em 27,18. O USD sofreu o impacto do FED que divulgou bons numeros no mercado de trabalho, jÃ¡ o JPY se manteve estavel mesmo com a melhora no aumento do PIB Japones. Links de notÃ­cias relevantes: infomoney.com/noticia123.'
### Dados: {df_gold}
"""

# ConfiguraÃ§Ã£o do Gemini
generation_config = {
    "max_output_tokens": 1000,  # Limita a resposta 1000 tokens
    "temperature": 0.5       # Torna a resposta mais focada
}

# Envia o prompt
response = model.generate_content(
  prompt
  #,generation_config=generation_config
)

# Imprime a resposta
df_ia = response.text

# Captura a quantidade de tokens do prompt
token_count = model.count_tokens(prompt)

# Gera Log
newsletter_logger.info(f"ConteÃºdo gerado com sucesso com {token_count}")

# Cria variaveis com resposta da IA, para armazenamento
ia_resp_output = { datetime.now().strftime('%Y-%m-%d %H:%M') : df_ia }
ia_resp_output_new = []

# Verifica se o arquivo JSON jÃ¡ existe e nÃ£o estÃ¡ vazio
if os.path.exists(ia_output_dir) and os.path.getsize(ia_output_dir) > 0:
    with open(ia_output_dir, 'r', encoding='utf-8') as f:
      ia_resp_output_new = json.load(f)

# Garante que os dados existentes sejam uma lista para poder adicionar.
if not isinstance(ia_resp_output_new, list):
    ia_resp_output_new = [ia_resp_output_new]

# Adicionar os novos dados Ã  lista.
ia_resp_output_new.append(ia_resp_output)

# Escreve a lista completa de volta no arquivo
with open(ia_output_dir, 'w', encoding='utf-8') as f:
    json.dump(ia_resp_output_new, f, ensure_ascii=False, indent=4)

# Gera Log
newsletter_logger.info(f"ConteÃºdo gravado com sucesso no arquivo: '{ia_output_dir}'")

"""## 6Â° PASSO: ENVIAR E-MAIL COM RELATÃ“RIO ğŸ“¨"""

# Gera Log
newsletter_logger.info("6Â° PASSO: ENVIAR E-MAIL COM RELATÃ“RIO")

# Envia o e-mail
assunto_email = "RelatÃ³rio DiÃ¡rio - CotaÃ§Ã£o das principais moedas"
corpo_email = f"{df_ia}"

enviar_email_com_anexo(
    remetente=meu_email,
    senha=minha_senha_app,
    destinatario=email_destinatario,
    assunto=assunto_email,
    corpo=corpo_email,
    caminho_anexo=graph_dir
)

"""# â€¼ï¸Validar LOG"""

with open("newsletter_logger.log", "r") as f:
  conteudo = f.read()

print(conteudo)

"""#â€¼ï¸Validar Output's IA"""

with open(ia_output_dir, "r") as f:
  conteudo = f.read()

print(conteudo)